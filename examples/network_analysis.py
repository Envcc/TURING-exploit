import numpy as np
import matplotlib.pyplot as plt
from turingexploit.network import dijkstra, ford_fulkerson, find_all_routes, kruskal, floyd_warshall
from turingexploit.analysis import bayesian_update, markov_chain, monte_carlo_simulation
from turingexploit.visualization import plot_graph, plot_routes
from turingexploit.ml import reinforcement_learning

# Define the network graph as a dictionary
network_graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

# Define the capacities for network flow analysis
capacities = {
    ('A', 'B'): 10, ('A', 'C'): 10,
    ('B', 'C'): 2, ('B', 'D'): 8,
    ('C', 'D'): 9
}

# Define transition probabilities for Markov Chain
transition_probabilities = {
    'A': {'B': 0.5, 'C': 0.5},
    'B': {'A': 0.3, 'C': 0.3, 'D': 0.4},
    'C': {'A': 0.4, 'B': 0.4, 'D': 0.2},
    'D': {'B': 0.6, 'C': 0.4}
}

# Compute the shortest paths from the starting node 'A'
shortest_paths = dijkstra(network_graph, 'A')

# Perform Bayesian analysis for target prioritization
prior_vulnerability = 0.1
likelihood_given_vulnerability = 0.9
evidence = 0.5
posterior = bayesian_update(prior_vulnerability, likelihood_given_vulnerability, evidence)

# Print the Bayesian posterior probability of vulnerability
print(f"Posterior Probability of Vulnerability: {posterior:.2f}")

# Compute the maximum flow from 'A' to 'D' using Ford-Fulkerson algorithm
max_flow = ford_fulkerson(capacities, 'A', 'D')

# Print the shortest paths from 'A' to all other nodes
print("Shortest Paths from 'A':")
for destination, (previous_node, path_cost) in shortest_paths.items():
    print(f"Destination: {destination}, Path Cost: {path_cost}, Previous Node: {previous_node}")

# Print the maximum flow result
print(f"Maximum Flow from 'A' to 'D': {max_flow}")

# Simulate Markov Chain transitions from 'A'
markov_simulation = markov_chain(transition_probabilities, 'A', steps=10)
print("Markov Chain Simulation from 'A':", markov_simulation)

# Find all possible routes from 'A' to all other nodes using DFS
all_routes = {}
for destination in network_graph:
    if destination != 'A':
        routes = find_all_routes(network_graph, 'A', destination)
        all_routes[destination] = routes

# Print all possible routes from 'A' to each destination
print("All Possible Routes from 'A':")
for destination, routes in all_routes.items():
    print(f"Destination: {destination}")
    for route in routes:
        print(f"  Route: {' -> '.join(route)}")

# Compute the Minimum Spanning Tree (MST) using Kruskal's algorithm
mst = kruskal(network_graph)
print("Minimum Spanning Tree (MST):", mst)

# Compute all-pairs shortest paths using Floyd-Warshall algorithm
all_pairs_shortest_paths = floyd_warshall(network_graph)
print("All-Pairs Shortest Paths:")
for i in all_pairs_shortest_paths:
    print(f"{i}: {all_pairs_shortest_paths[i]}")

# Perform Monte Carlo simulation for network performance analysis
monte_carlo_results = monte_carlo_simulation(network_graph, iterations=1000)
print("Monte Carlo Simulation Results:", monte_carlo_results)

# Apply reinforcement learning for adaptive network optimization
optimal_policy = reinforcement_learning(network_graph, capacities)
print("Optimal Policy from Reinforcement Learning:", optimal_policy)

# Plot the network graph with weights and capacities
plot_graph(network_graph, capacities)

# Plot all possible routes
plot_routes(network_graph, all_routes)
